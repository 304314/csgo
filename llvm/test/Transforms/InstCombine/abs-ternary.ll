; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -enable-ternary-abs-optimization -S | FileCheck %s

declare i32 @abs(i32)
declare i32 @llvm.abs.i32(i32, i1)

; x>y ? abs(x-y+1) : 0 -> x>y ? x-y+1 : 0
; https://alive2.llvm.org/ce/z/XZsbMD
define i32 @abs_sub_with_pos_constant_sgt(i32 %x, i32 %y) {
; CHECK-LABEL: @abs_sub_with_pos_constant_sgt(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_END:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[X]], [[Y]]
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[SUB]], 1
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi i32 [ [[ADD]], [[COND_TRUE]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[COND]]
;
entry:
  %cmp = icmp sgt i32 %x, %y
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:
  %sub = sub nsw i32 %x, %y
  %add = add nsw i32 %sub, 1
  %call = call i32 @abs(i32 %add)
  br label %cond.end

cond.end:
  %cond = phi i32 [ %call, %cond.true ], [ 0, %entry ]
  ret i32 %cond
}

; only optimize abs() call to select expression
; https://alive2.llvm.org/ce/z/fMVLDa
define i32 @abs_sub_with_pos_constant_sgt_nonsw(i32 %x, i32 %y) {
; CHECK-LABEL: @abs_sub_with_pos_constant_sgt_nonsw(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_END:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    [[SUB:%.*]] = sub i32 [[X]], [[Y]]
; CHECK-NEXT:    [[ADD:%.*]] = add i32 [[SUB]], 1
; CHECK-NEXT:    [[TMP0:%.*]] = icmp slt i32 [[ADD]], 0
; CHECK-NEXT:    [[NEG:%.*]] = xor i32 [[SUB]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = select i1 [[TMP0]], i32 [[NEG]], i32 [[ADD]]
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi i32 [ [[TMP1]], [[COND_TRUE]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[COND]]
;
entry:
  %cmp = icmp sgt i32 %x, %y
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:
  %sub = sub i32 %x, %y
  %add = add i32 %sub, 1
  %call = call i32 @abs(i32 %add)
  br label %cond.end

cond.end:
  %cond = phi i32 [ %call, %cond.true ], [ 0, %entry ]
  ret i32 %cond
}

; x>=y ? abs(x-y+2) : 0 -> x>=y ? x-y+2 : 0
; https://alive2.llvm.org/ce/z/APiJXd
define i32 @abs_sub_with_pos_constant_sge(i32 %x, i32 %y) {
; CHECK-LABEL: @abs_sub_with_pos_constant_sge(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp slt i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP_NOT]], label [[COND_END:%.*]], label [[COND_TRUE:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[X]], [[Y]]
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[SUB]], 2
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi i32 [ [[ADD]], [[COND_TRUE]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[COND]]
;
entry:
  %cmp = icmp sge i32 %x, %y
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:
  %sub = sub nsw i32 %x, %y
  %add = add nsw i32 %sub, 2
  %call = call i32 @abs(i32 %add)
  br label %cond.end

cond.end:
  %cond = phi i32 [ %call, %cond.true ], [ 0, %entry ]
  ret i32 %cond
}

; x<y ? abs(x-y+1) : 0 -> x<y ? y-x-1 : 0
; https://alive2.llvm.org/ce/z/jBfQX5
define i32 @abs_sub_with_pos_constant_slt(i32 %x, i32 %y) {
; CHECK-LABEL: @abs_sub_with_pos_constant_slt(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_END:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    [[TMP0:%.*]] = xor i32 [[X]], -1
; CHECK-NEXT:    [[NEG:%.*]] = add i32 [[TMP0]], [[Y]]
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi i32 [ [[NEG]], [[COND_TRUE]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[COND]]
;
entry:
  %cmp = icmp slt i32 %x, %y
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:
  %sub = sub nsw i32 %x, %y
  %add = add nsw i32 %sub, 1
  %call = call i32 @abs(i32 %add)
  br label %cond.end

cond.end:
  %cond = phi i32 [ %call, %cond.true ], [ 0, %entry ]
  ret i32 %cond
}

; only optimize abs() call to select expression
; https://alive2.llvm.org/ce/z/e9VkdM
define i32 @abs_sub_with_pos_constant_sle(i32 %x, i32 %y) {
; CHECK-LABEL: @abs_sub_with_pos_constant_sle(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp sgt i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP_NOT]], label [[COND_END:%.*]], label [[COND_TRUE:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[X]], [[Y]]
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[SUB]], 1
; CHECK-NEXT:    [[TMP0:%.*]] = icmp slt i32 [[SUB]], -1
; CHECK-NEXT:    [[NEG:%.*]] = xor i32 [[SUB]], -1
; CHECK-NEXT:    [[TMP1:%.*]] = select i1 [[TMP0]], i32 [[NEG]], i32 [[ADD]]
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi i32 [ [[TMP1]], [[COND_TRUE]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[COND]]
;
entry:
  %cmp = icmp sle i32 %x, %y
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:
  %sub = sub nsw i32 %x, %y
  %add = add nsw i32 %sub, 1
  %call = call i32 @abs(i32 %add)
  br label %cond.end

cond.end:
  %cond = phi i32 [ %call, %cond.true ], [ 0, %entry ]
  ret i32 %cond
}

; only optimize abs() call to select expression
define i32 @abs_sub_with_neg_constant_slt(i32 %x, i32 %y) {
; CHECK-LABEL: @abs_sub_with_neg_constant_slt(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_END:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    [[DOTNEG:%.*]] = add i32 [[Y]], 1
; CHECK-NEXT:    [[SUB1_NEG:%.*]] = sub i32 [[DOTNEG]], [[X]]
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi i32 [ [[SUB1_NEG]], [[COND_TRUE]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[COND]]
;
entry:
  %cmp = icmp slt i32 %x, %y
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:
  %sub = sub nsw i32 %x, %y
  %sub1 = sub nsw i32 %sub, 1
  %call = call i32 @abs(i32 %sub1)
  br label %cond.end

cond.end:
  %cond = phi i32 [ %call, %cond.true ], [ 0, %entry ]
  ret i32 %cond
}

; x<=y ? abs(x-y-3) : 0 -> x<=y ? y-x+3: 0
; https://alive2.llvm.org/ce/z/z73eBY
define i32 @abs_sub_with_neg_constant_sle(i32 %x, i32 %y) {
; CHECK-LABEL: @abs_sub_with_neg_constant_sle(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp slt i32 [[Y:%.*]], [[X:%.*]]
; CHECK-NEXT:    br i1 [[CMP_NOT]], label [[COND_END:%.*]], label [[COND_TRUE:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    [[SUB_NEG:%.*]] = sub i32 [[Y]], [[X]]
; CHECK-NEXT:    [[NEG:%.*]] = add i32 [[SUB_NEG]], 3
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi i32 [ [[NEG]], [[COND_TRUE]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[COND]]
;
entry:
  %cmp = icmp sle i32 %x, %y
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:
  %sub = sub nsw i32 %x, %y
  %sub1 = sub nsw i32 %sub, 3
  %call = call i32 @abs(i32 %sub1)
  br label %cond.end

cond.end:
  %cond = phi i32 [ %call, %cond.true ], [ 0, %entry ]
  ret i32 %cond
}

; only optimize abs() call to select expression
define i32 @abs_sub_with_neg_constant_sgt(i32 %x, i32 %y) {
; CHECK-LABEL: @abs_sub_with_neg_constant_sgt(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_END:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    [[TMP0:%.*]] = xor i32 [[Y]], -1
; CHECK-NEXT:    [[SUB1:%.*]] = add i32 [[TMP0]], [[X]]
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi i32 [ [[SUB1]], [[COND_TRUE]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[COND]]
;
entry:
  %cmp = icmp sgt i32 %x, %y
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:
  %sub = sub nsw i32 %x, %y
  %sub1 = sub nsw i32 %sub, 1
  %call = call i32 @abs(i32 %sub1)
  br label %cond.end

cond.end:
  %cond = phi i32 [ %call, %cond.true ], [ 0, %entry ]
  ret i32 %cond
}

; only optimize abs() call to select expression
define i32 @abs_sub_with_neg_constant_sge(i32 %x, i32 %y) {
; CHECK-LABEL: @abs_sub_with_neg_constant_sge(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp slt i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP_NOT]], label [[COND_END:%.*]], label [[COND_TRUE:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    [[TMP0:%.*]] = xor i32 [[Y]], -1
; CHECK-NEXT:    [[SUB1:%.*]] = add i32 [[TMP0]], [[X]]
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.abs.i32(i32 [[SUB1]], i1 true)
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[COND:%.*]] = phi i32 [ [[TMP1]], [[COND_TRUE]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[COND]]
;
entry:
  %cmp = icmp sge i32 %x, %y
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:
  %sub = sub nsw i32 %x, %y
  %sub1 = sub nsw i32 %sub, 1
  %call = call i32 @abs(i32 %sub1)
  br label %cond.end

cond.end:
  %cond = phi i32 [ %call, %cond.true ], [ 0, %entry ]
  ret i32 %cond
}

; only optimize abs() call to select expression
define i32 @abs_sub_with_pos_multiply(i32 %x, i32 %y) {
; CHECK-LABEL: @abs_sub_with_pos_multiply(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_END:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[X]], [[Y]]
; CHECK-NEXT:    [[MUL:%.*]] = shl nsw i32 [[SUB]], 1
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[R:%.*]] = phi i32 [ [[MUL]], [[COND_TRUE]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[R]]
;
entry:
  %cmp = icmp sgt i32 %x, %y
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:
  %sub = sub nsw i32 %x, %y
  %mul = shl nsw i32 %sub, 1
  %0 = call i32 @llvm.abs.i32(i32 %mul, i1 true)
  br label %cond.end

cond.end:
  %r = phi i32 [ %0, %cond.true ], [ 0, %entry ]
  ret i32 %r
}

; only optimize abs() call to select expression
define i32 @abs_sub_with_neg_multiply(i32 %x, i32 %y) {
; CHECK-LABEL: @abs_sub_with_neg_multiply(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[X:%.*]], [[Y:%.*]]
; CHECK-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_END:%.*]]
; CHECK:       cond.true:
; CHECK-NEXT:    [[SUB:%.*]] = sub nsw i32 [[X]], [[Y]]
; CHECK-NEXT:    [[MUL_NEG:%.*]] = mul i32 [[SUB]], 3
; CHECK-NEXT:    br label [[COND_END]]
; CHECK:       cond.end:
; CHECK-NEXT:    [[R:%.*]] = phi i32 [ [[MUL_NEG]], [[COND_TRUE]] ], [ 0, [[ENTRY:%.*]] ]
; CHECK-NEXT:    ret i32 [[R]]
;
entry:
  %cmp = icmp sgt i32 %x, %y
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:
  %sub = sub nsw i32 %x, %y
  %mul = mul nsw i32 %sub, -3
  %0 = call i32 @llvm.abs.i32(i32 %mul, i1 true)
  br label %cond.end

cond.end:
  %r = phi i32 [ %0, %cond.true ], [ 0, %entry ]
  ret i32 %r
}
